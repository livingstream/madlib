# coding=utf-8
import plpy
import random
import time
from utilities.validate_args import table_exists
from utilities.validate_args import columns_exist_in_table
from utilities.utilities import _assert


def __runAlg(stateType, initialState, source, updateExpr):
    updateSQL = """
        INSERT INTO _madlib_alg
        SELECT {updateExpr}
        FROM
            _madlib_alg AS st,
            {{source}} AS src
        """.format(updateExpr = updateExpr)

    plpy.execute("""
        DROP TABLE IF EXISTS _madlib_alg;
        CREATE TEMPORARY TABLE _madlib_alg (
            _madlib_state {stateType}
        )
        """.format(stateType = stateType))
   
    plpy.execute("""
        INSERT INTO _madlib_alg VALUES ({initialState})
        """.format(initialState = initialState))
 
    plpy.execute(updateSQL.format(
	source = source,
	state = "(st._madlib_state)",
	iteration = 0,
	sourceAlias = "src"))
    
def compute_gibbs(schema_madlib, source, clause, weight, component, num_atom, state_size, query, **kwargs):
    return __runAlg(
        stateType = "FLOAT8[]",
        initialState = "NULL",
        source = source,
        updateExpr = """
            {schema_madlib}.gibbs_step(
                ({clause})::FLOAT8[],
                ({weight})::FLOAT8,
                ({component})::FLOAT8,
                ({num_atom})::FLOAT8,
                ({state_size})::FLOAT8,
                ({query})::FLOAT8,
                {{state}}
            )
            """.format(
                schema_madlib = schema_madlib,
                clause = clause,
                weight = weight,
                component = component,
                num_atom = num_atom,
                state_size = state_size,
                query = query))

def init(schema_madlib, clause_tbl, **kwargs):
    plpy.notice("enter init")
    plpy.execute("""CREATE INDEX cnum_idx ON {clause_tbl} (cnum)""".format(clause_tbl = clause_tbl))
    plpy.execute("""ANALYZE {clause_tbl}""".format(clause_tbl = clause_tbl))
    plpy.execute("""CREATE TEMP TABLE cnum_lit AS
                    SELECT cnum, abs(unnest(clause)) lit, array_length(clause, 1) len 
                    FROM {clause_tbl}""".format(clause_tbl = clause_tbl))
    plpy.execute('CREATE INDEX lit_idx ON cnum_lit (lit)')

    plpy.execute("""CREATE TEMP TABLE lit_cnums AS
                    SELECT lit, array_agg(cnum) cnums, array_agg(len) lens
                    FROM cnum_lit
                    GROUP BY lit""")
    plpy.execute('CREATE INDEX lit_cnums_indx ON lit_cnums (lit)')

    plpy.execute("""CREATE TEMP TABLE atom_path AS
                    SELECT DISTINCT c1.lit src, c2.lit des
                    FROM cnum_lit c1, cnum_lit c2 
                    WHERE c1.cnum = c2.cnum and c1.lit <> c2.lit""")
    plpy.execute('CREATE INDEX src_idx ON atom_path (src)')

def qdr_infer(schema_madlib, clause_tbl, num_hop, querytbl, **kwargs):
    plpy.notice("L0: begin ")
    n1=time.time() 
    plpy.execute('DROP TABLE IF EXISTS atoms, unique_atoms, atom_map, new_clause_tbl, cnum_tbl')
    plpy.execute('DROP SEQUENCE IF EXISTS serial')
    n2=time.time() 
    plpy.notice("L1: " + str(n2-n1))
    plpy.execute("""CREATE TEMP TABLE atoms(id INT);
                    CREATE TEMP SEQUENCE serial START 1;
                    WITH RECURSIVE path_cte (id, depth, path, cycle) as 
                    (  SELECT """ + str(querytbl) + """, 0, ARRAY[""" + str(querytbl) + """], false
                       UNION ALL
                       SELECT nxt.des, depth+1, path || nxt.des, nxt.des = ANY(path)
                       FROM atom_path nxt, path_cte prv
                       WHERE  nxt.src = prv.id AND NOT cycle 
                              AND depth < """ + str(num_hop) + """
                    )
                    INSERT INTO atoms
                    SELECT id FROM path_cte WHERE cycle = false LIMIT 500""")
    n3=time.time() 
    plpy.notice("L2: " + str(n3-n2))
   
    plpy.execute("""SELECT DISTINCT id 
                    INTO   unique_atoms
                    FROM   atoms""") 

    plpy.execute('CREATE INDEX unique_atom_idx ON unique_atoms (id)')

    rv = plpy.execute('SELECT COUNT(*) AS num_atom FROM unique_atoms');
    num_atom = rv[0]['num_atom']

    plpy.execute("""CREATE TABLE cnum_tbl AS
                    SELECT cnum
                    FROM (SELECT cnum, len, COUNT(*) cnt
                          FROM (SELECT lit, unnest(cnums) cnum, unnest(lens) len
                                FROM lit_cnums, unique_atoms
                                WHERE lit = id) AS U
                          GROUP BY cnum, len) AS V
                    WHERE len = cnt""")

    plpy.execute('CREATE INDEX cnum_tbl_idx ON cnum_tbl(cnum)')
    n4=time.time() 
    plpy.notice("L3: " + str(n4-n3))
     
    plpy.execute("""ANALYZE cnum_tbl""")
    plpy.execute("""CREATE TABLE new_clause_tbl AS
                    SELECT cnum_tbl.cnum, clause, weight, component
                    FROM  {clause_tbl}, cnum_tbl
                    WHERE {clause_tbl}.cnum = cnum_tbl.cnum
                 """.format(clause_tbl = clause_tbl, schema_madlib = schema_madlib)) 

    n5=time.time() 
    plpy.notice("L4: " + str(n5-n4))
    rv = plpy.execute('SELECT sum(array_length(clause, 1) + 3) AS state_size FROM new_clause_tbl');            
    state_size = rv[0]['state_size']    

    plpy.execute("""SELECT {schema_madlib}.compute_gibbs('new_clause_tbl', 'clause', 'weight', 
                    'component', {num_atom}, {state_size}, {querytbl})
                        """.format(schema_madlib = schema_madlib, 
                                   num_atom = str(num_atom),
                                   state_size = str(state_size),
                                   querytbl = str(querytbl)))
   
    n6=time.time() 
    plpy.notice("L5: " + str(n6-n5))
    rv = plpy.execute("""SELECT (result).truth[1] prob
                       FROM (SELECT {schema_madlib}.internal_gibbs_result(_madlib_state) AS result
                             FROM _madlib_alg
                            ) Q
                       WHERE array_length((result).truth, 1) != 0       
                 """.format(schema_madlib = schema_madlib))
    n7=time.time() 
    plpy.notice("L6: " + str(n7-n6))
    return rv[0]['prob']

def init_comp(schema_madlib, **kwargs):
    plpy.execute("""CREATE TABLE components_to_merge AS
                    SELECT src comp1, des comp2 
                    FROM atom_path""")
    
    plpy.execute("""CREATE TABLE lit_component AS
                    SELECT lit, lit AS comp, cnums
                    FROM lit_cnums""")

    plpy.execute('CREATE INDEX lit_component_idx ON lit_component(lit)')

    rv = plpy.execute('SELECT COUNT(*) AS cnt FROM components_to_merge')
    iteration = 0
    while rv[0]['cnt'] != 0:
          iteration = iteration + 1
          plpy.notice("iteration = " + str(iteration) + " : components_to_merge = " + str(rv[0]['cnt']))
          plpy.execute("""
          UPDATE lit_component
          SET comp = least(comp, target)
          FROM (SELECT comp1 , min(comp2) target 
                FROM components_to_merge 
                GROUP BY comp1) new_components 
          WHERE new_components.comp1 = comp""") 
          
          plpy.execute('TRUNCATE components_to_merge')
          
          plpy.execute("""
          INSERT INTO components_to_merge 
          SELECT DISTINCT t1.comp, t2.comp 
          FROM atom_path join lit_component t1 on atom_path.src = t1.lit 
                         join lit_component t2 on atom_path.des = t2.lit 
          WHERE t1.comp != t2.comp""")
          rv = plpy.execute('SELECT COUNT(*) AS cnt FROM components_to_merge')
    
    plpy.execute("""CREATE TABLE cnum_comp_tbl AS
                    SELECT distinct unnest(cnums), comp
                    FROM lit_component""")
     

def batch_infer(schema_madlib, clause_tbl, truth_tbl, **kwargs):
    rv = plpy.execute('SELECT COUNT(*) AS num_atom FROM lit_cnums')
    num_atom = rv[0]['num_atom']

    rv = plpy.execute("""SELECT sum(array_length(clause, 1) + 3) AS state_size 
                      FROM {clause_tbl}""".format(clause_tbl = clause_tbl));            
    state_size = rv[0]['state_size']    
    plpy.execute("""SELECT {schema_madlib}.compute_gibbs('{clause_tbl}', 'clause', 'weight', 
                         'component', {num_atom}, {state_size}, '-1')
                        """.format(schema_madlib = schema_madlib, 
                                   clause_tbl = clause_tbl,
                                   num_atom = str(num_atom),
                                   state_size = str(state_size)))

    plpy.execute("""CREATE TABLE {truth_tbl} AS
                    SELECT * 
                    FROM unnest_rownum(
                         (SELECT (result).truth truth
                          FROM (SELECT {schema_madlib}.internal_gibbs_result(_madlib_state) AS result 
                                FROM _madlib_alg) Q
                          WHERE array_length((result).truth, 1) != 0)) 
                 """.format(truth_tbl = truth_tbl, schema_madlib = schema_madlib))
    return "batch infer is done!"

def qdr_infer_eval(schema_madlib, clause_tbl, result_tbl, num_hop, num_test, **kwargs):
    plpy.execute("""DROP TABLE IF EXISTS {result_tbl}
                 """.format(result_tbl = result_tbl))
    plpy.execute("""CREATE TABLE {result_tbl} (lit INT, prob REAL)
                 """.format(result_tbl = result_tbl))
    rv = plpy.execute('SELECT COUNT(*) AS num_atom FROM lit_cnums')
    num_atom = rv[0]['num_atom']
    test_nodes = random.sample(range(1, num_atom + 1), num_test)
    for node in test_nodes:
        rv = plpy.execute("""SELECT {schema_madlib}.qdr_infer('{clause_tbl}', {num_hop}, {node}) prob
                          """.format(schema_madlib = schema_madlib, clause_tbl = clause_tbl, 
                                     num_hop = str(num_hop), node = str(node)))       
        prob = rv[0]['prob']
        plpy.execute("""INSERT INTO {result_tbl} VALUES ({node} , {prob})
                     """.format(result_tbl = result_tbl, node = str(node), prob = str(prob)))
    return "benchmark query driven inference is done!"
